from typing import Any, Dict, Optional, Tuple, Union

import numpy as np
import torch
from torch.nn.modules import Module
from torch.nn.modules.loss import _Loss
from torch.utils.data import Dataset
from sklearn.base import BaseEstimator

from . import modules as modules

class BaseRunner(BaseEstimator):
    device: torch.device = ...
    model: Module = ...
    criterion: _Loss = ...
    optimizer: Any = ...
    logger: Any = ...
    scheduler: Any = ...
    def __init__(self, model: Module, criterion: _Loss, optimizer: Any, optim_config: Dict, device: Union[torch.device, str] = ..., experiment: Optional[Any] = ..., scheduler: Optional[Any] = ...) -> None: ...
    def one_cycle(self, data: torch.Tensor, target: torch.Tensor) -> torch.Tensor: ...
    def validate(self, data: torch.Tensor, target: torch.Tensor) -> Dict[str, torch.Tensor]: ...
    def fit(self, dataset: Dataset, epochs: int, batch_size: int, shuffle: bool = ..., checkpoint: str = ..., validation: Optional[Any] = ..., **loader_config: Any): ...
    def predict(self, x: torch.Tensor) -> np.ndarray: ...
    def evaluate(self, dataset: Dataset, batch_size: int) -> Any: ...
    def save_checkpoint(self) -> dict: ...
    def load_checkpoint(self, checkpoint: dict) -> Any: ...
    def save(self, directory: str, epoch: int=...) -> None: ...
    def load(self, filename: str, map_location: str=...) -> None: ...

class ClassificationRunner(BaseRunner):
    def predict(self, x: torch.Tensor) -> np.ndarray: ...
    def evaluate(self, dataset: Dataset, batch_size: int=...) -> Tuple[float, float]: ...
