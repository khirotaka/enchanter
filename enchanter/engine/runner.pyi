from collections import OrderedDict
from abc import ABC, abstractmethod, ABCMeta
from typing import Any, Dict, Tuple, Union, List, Optional

from numpy import ndarray
from tqdm import tqdm as tqdm
from tqdm.notebook import tqdm_notebook as tqdm_notebook
from sklearn.base import BaseEstimator
from torch.nn import Module
from torch import Tensor, device as torch_device
from torch.utils.data import DataLoader as DataLoader
from torch.optim.optimizer import Optimizer as Optimizer
from torch.optim.lr_scheduler import _LRScheduler as _LRScheduler
from comet_ml.experiment import BaseExperiment as BaseExperiment

from enchanter.callbacks import BaseLogger as BaseLogger
from enchanter.callbacks import EarlyStopping as EarlyStopping


class BaseRunner(BaseEstimator, ABC, metaclass=ABCMeta):
    model: Module = ...
    optimizer: Optimizer = ...
    experiment: Union[BaseExperiment, BaseLogger] = ...
    device: torch_device = ...
    pbar: Optional[Union[tqdm, tqdm_notebook]] = ...
    scheduler: Optional[_LRScheduler] = ...
    early_stop: Optional[EarlyStopping] = ...

    _epochs: int = ...
    _loaders: Dict[str, DataLoader] = ...
    _metrics: Dict = ...
    _checkpoint_path: Optional[str] = ...

    def __init__(self) -> None: ...
    @abstractmethod
    def backward(self, loss: Tensor) -> None: ...
    def update_optimizer(self) -> None: ...
    def train_step(self, batch: Tuple) -> Dict[str, Tensor]: ...
    def train_end(self, outputs: List) -> Dict[str, Tensor]: ...
    def val_step(self, batch: Tuple) -> Dict[str, Tensor]: ...
    def val_end(self, outputs: List) -> Dict[str, Tensor]: ...
    def test_step(self, batch: Tuple) -> Dict[str, Tensor]: ...
    def test_end(self, outputs: List) -> Dict[str, Tensor]: ...
    def train_cycle(self, epoch: int, loader: DataLoader) -> None: ...
    def val_cycle(self, epoch: int, loader: DataLoader) -> None: ...
    def test_cycle(self, loader: DataLoader) -> None: ...
    def train_config(self, epochs: int, **kwargs: Any) -> None: ...
    def log_hyperparams(self, dic: Dict=..., prefix: str=...) -> None: ...
    def initialize(self) -> None: ...
    def run(self, verbose: bool = ...) -> None: ...
    def predict(self, x: Union[Tensor, ndarray]) -> ndarray: ...
    def add_loader(self, mode: str, loader: DataLoader): ...
    @property
    def loaders(self) -> Dict[str, DataLoader]: ...
    def fit(self, x: ndarray, y: ndarray, **kwargs) -> None: ...
    def freeze(self) -> None: ...
    def unfreeze(self) -> None: ...
    def save_checkpoint(self) -> Dict[str, OrderedDict]: ...
    def load_checkpoint(self, checkpoint: Dict[str, OrderedDict]) -> None: ...
    def save(self, directory: Optional[str] = ..., epoch: Optional[int] = ...) -> None: ...
    def load(self, filename: str, map_location: str = ...) -> None: ...

